# Analysis of scheduling algorithms

We'll explore several scheduling algorithms in this analysis. But first, let's settle some terms.

## Terms

- User: Module that generates messages periodically;
- User count: The number of users
- Unlucky user: user which loses their connectivity (i.e. won't be able to forward its messages) for a certain period of time;
- Sink: Module which receives all the messages generated by the users;
- Scheduler: Module which controls how many messages a user will be able to forward to the sink in a scheduling cycle, given a specific scheduling algorithm;
- Scheduling algorithm: a plan which decides how many channels should be allocated to a user;
- Weights: An array of values which indicates how important are a user's packets;
- Channel count: A value showing how many channels can be distributed among users.

## Scheduling algorithms

### **Dummy**

Let's say that we have $N = 4$ users, our array of weights looks like this: $w = [1, 2, 3, 4]$ and we have $C = 30$ channels to distribute.
$$
w_0+w_1+w_2+w_3=1+2+3+4=10
$$
This means that for a weight of $1$, a user will receive $factor=1 \times \frac {30} {10}=3$ channels.

So, $user_0$ will receive $c_0 = w_0 \times factor = 3$, while the others will receive $c_1 = 6$, $c_2 = 9$, $c_3 = 12$.

The Dummy algorithm will allocate the above mentioned channels each scheduling cycle - even if $user_k$ did not generate $c_k$ messages. This can lead to channels which are not used - and users with a low weight might get several messages stuck in their queue.

Let's take a very similar example.
Say we have $N = 4$ users, an array of weights $w = [1, 2, 2, 3]$ and $C = 30$ channels to distribute.
$$
w_0+w_1+w_2+w_3=1+2+2+3=8
$$
This means that for a weight of $1$, a user will receive $factor=1 \times \frac {30} {8}=3.75$ channels.

So, $user_0$ will receive $c_0 = w_0 \times factor = 3.75$, while the others will receive $c_1 = 7.5$, $c_2 = 7.5$, $c_3 = 11.25$.

These, should be integer values, of course.

So we take the integer parts and keep the remaining difference.
$c_0 = 3, c_1 = 7$, $c_2 = 7$, $c_3 = 11$.

The remaining $30 - (3+7+7+11)=2$ channels are going to be distributed one by one, starting from the first user.

Finally, we'll obtain: $c_0 = 4, c_1 = 8$, $c_2 = 7$, $c_3 = 11$.

These values change only when the unlucky user loses their connection.

Their weight gets set to zero, triggering a change in the channels allocated. Let's go back to our first example.

$C=30$; $w_0 = 1$, $w_1 = 2$, $w_2 = 3$, $w_3 = 4$

If $user_3$ loses their connection, the weights become: $w_0 = 1$, $w_1 = 2$, $w_2 = 3$, $w_3 = 0$

And consequently, the allocated channels: $c_0 = 5$, $c_1 = 10$, $c_2 = 15$, $c_3 = 0$

Once the unlucky user comes back online with a changed weight, e.g. $w_3 = 9$, the weights become:

$w_0 = 1$, $w_1 = 2$, $w_2 = 3$, $w_3 = 9$

Then, the allocated channels: $c_0 = 2$, $c_1 = 4$, $c_2 = 6$, $c_3 = 18$.

### **Queue Aware**

The Queue Aware algorithm will also taken into account the length of each user's queue.

At first, we do a naive Dummy allocation. We'll probably find a user which produced less messages then they are able to send. We keep count of such users and the remaining channels that they leave behind.

Let's take the previous example:

$w_0 = 1$, $w_1 = 2$, $w_2 = 3$, $w_3 = 4$, $C=30$ and

$c_0 = 3$, $c_1 = 6$, $c_2 = 9$, $c_3 = 12$.

Let's say that these are the query lengths:

$q_0 = 9$, $q_1 = 6$, $q_2 = 10$, $q_3 = 2$.

We can see that $user_0$ and $user_2$ exceed their allocated channels, $user_1$ hits just enough and $user_3$ produced much less.

Allocate all those channels that can and should be allocated, that is:

$c'_0 = 3$, $c'_1 = 6$, $c'_2 = 9$, $c'_3 = 2$.

We are left with 10 more channels waiting to be allocated (the last user only consumed 2 out of its allocated 12).

We'll do another dummy allocation, but keeping in mind those clients that have been fully served and reduce their weight to zero.

$w'_0 = 1$, $w'_1 = 0$, $w'_2 = 3$, $w'_3 = 0$, $C'=10$ and then accordingly:

$c''_0 = 2.5$, $c''_1 = 0$, $c''_2 = 7.5$, $c''_3 = 0$ or rather

$c''_0 = 3$, $c''_1 = 0$, $c''_2 = 7$, $c''_3 = 0$

So now, for the final allocations: $c_k$ = $c'_k$ + $c''_k$.

$c_0 = 6$, $c_1 = 6$, $c_2 = 16$, $c_3 = 2$.

We can continue this process until we get to an optimal resource allocation. This algorithm will do the optimization only once.
